---
layout: post
title:  "JAVA多线程系列-死锁"
date:    2016-06-03 14:20
categories: Java
comment: true
---

多个线程进行资源竞争，资源的同步不当，便会引发程序的无限等待，即是我们所说的死锁。
本章讲述死锁的原理，以“哲学家就餐问题”进行死锁举例，以及提出避免死锁一些方法。


## 死锁的概念

两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。

### 死锁条件：

 * 1：互斥条件：线程占有资源的互斥访问。
 * 2：请求与保持条件：线程至少拥有一个资源，但又需要其他资源，进而阻塞。
 * 3：不可剥夺条件：线程已获得的资源，在使用完之前，不可以强行剥夺，只能自己释放。
 * 4：循环等待条件：若干进程请求的资源


## 死锁模型-哲学家就餐问题
死锁模型：
哲学家就餐问题：

```java


```

## 死锁避免

4.5 死锁的预防
4.6 死锁的避免
4.7 死锁的检测与忽略

死锁避免：
### 银行家算法

银行家算法是一种预分配算法，
银行家类似操作系统，线程所需的资源就好比银行里的钱，线程申请资源好比是从银行里贷款。
当进程首次申请资源时，操作系统会测试进程所需的最大资源，若超过系统现有资源的总和，则推迟分配，否者正常分配。

当进程运行中再次申请资源时，操作系统会测试这次资源的申请量+进程已占有的资源量是否超过进程的最大需求量，如超过则拒绝分配。若没超过，再比较本次申请的资源与系统目前的资源总量，若超过，则推迟分配，否者正常分配。

http://blog.csdn.net/yaopeng_2005/article/details/6935235


Java死锁避免举例：

银行家算法
```Java


```
