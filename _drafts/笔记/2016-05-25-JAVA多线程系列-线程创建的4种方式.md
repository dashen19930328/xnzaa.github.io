---
layout: post
title:  "JAVA多线程系列-线程创建的4种方式"
date:    2016-05-25 21:20
categories: Java
comment: true
---

## 线程创建的4种方式

### Runnable创建线程

```java
public static void main(String[] args)
{	
	System.out.println(Thread.currentThread().getName()+" is Running");
	new Thread((new Create()).new  MyRunnable(),"线程1").start();
	new Thread((new Create()).new  MyThread(),"线程2").start();
}

public class MyRunnable implements Runnable
{
	@Override
	public void run() {
		try {
			Thread.sleep(500);//单位ms
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println(Thread.currentThread().getName()+" is Running");
	}
}

```

### Thread创建线程

```java

public class MyThread extends Thread
{
	@Override
	public void run() {
		System.out.println(Thread.currentThread().getName()+" is Running");
	}
}

```

### 线程池管理线程

```java
public static void main(String[] arg)
{
	//单次调度
//	ExecutorService pool=Executors.newSingleThreadExecutor();//单个线程的线程池
//	ExecutorService pool=Executors.newFixedThreadPool(2);//最大同时运行2个线程池
//	ExecutorService pool=Executors.newCachedThreadPool();//自动调整大小的线程池
			
	//周期调度线程
//	ScheduledExecutorService  pool=Executors.newSingleThreadScheduledExecutor();//单个周期线程的线程池
	ScheduledExecutorService  pool=Executors.newScheduledThreadPool(2);//2个周期线程的线程池
	pool.scheduleAtFixedRate(new Thread(new MyRunnable(),"t1"),1,1,TimeUnit.SECONDS);//设置调用周期
	
	pool.execute(new Thread(new MyRunnable(),"t1"));
	pool.execute(new Thread(new MyRunnable(),"t2"));
	pool.execute(new Thread(new MyRunnable(),"t3"));
//	pool.shutdown();
	System.out.println("hello");
}

public static class MyRunnable implements Runnable
{
	@Override
	public void run() {
		System.out.println(Thread.currentThread().getName()+" is Running");
	}
}

```

### 创建有返回值的线程

```java
public static void main(String[] args)
{
	Future<String> future1=pool.submit(new MyThread());
	try {
		Thread.sleep(100);
		System.out.println("返回值为："+future1.get().toString());
	} catch (Exception e) {
		e.printStackTrace();
	}
}

public static class MyThread implements Callable <String>
{
	@Override
	public String call() throws Exception {
		// TODO Auto-generated method stub
		return "我是返回值！";
	}
	
}

```

### Runnable&Thread创建线程区别：

1：前者方便实现数据共享；
2：前者避免了Java单继承的局限性，可以继承多个接口。


